{"meta":{"title":"faceplus's home","subtitle":"小伙子","description":"来自前端星球的小伙子","author":"slipkinem","url":"http://faceplus.top"},"pages":[{"title":"","date":"2017-10-26T03:35:16.062Z","updated":"2017-10-26T03:33:01.064Z","comments":true,"path":"google1667bfa5324d9102.html","permalink":"http://faceplus.top/google1667bfa5324d9102.html","excerpt":"","text":"google-site-verification: google1667bfa5324d9102.html"},{"title":"标签","date":"2017-04-13T08:18:17.000Z","updated":"2017-08-22T06:07:03.489Z","comments":true,"path":"tags/index.html","permalink":"http://faceplus.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-22T05:58:29.000Z","updated":"2017-08-22T06:07:30.472Z","comments":true,"path":"categories/index.html","permalink":"http://faceplus.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"修改vue的keep-alive实现仿easyui-页面tab切换","slug":"vue-tab-look-like-easyui","date":"2017-10-27T09:08:06.000Z","updated":"2017-10-30T07:19:04.357Z","comments":true,"path":"2017/10/27/vue-tab-look-like-easyui/","link":"","permalink":"http://faceplus.top/2017/10/27/vue-tab-look-like-easyui/","excerpt":"后台管理页面通常会有tabs切换作为导航常见实现方式 通过显示和隐藏div（缺点：无法看到路由） 通过iframe，其实和显示隐藏区别不大vue实现方式因为要在vue中实现，用vue-router和vue中一个keep-alive，但是keep-alive有个缺点，他是用对象来缓存组件，并且是一个抽象组件，所以就稍微修改下。 效果图","text":"后台管理页面通常会有tabs切换作为导航常见实现方式 通过显示和隐藏div（缺点：无法看到路由） 通过iframe，其实和显示隐藏区别不大vue实现方式因为要在vue中实现，用vue-router和vue中一个keep-alive，但是keep-alive有个缺点，他是用对象来缓存组件，并且是一个抽象组件，所以就稍微修改下。 效果图 功能 点击左侧显示toolbar nav 通过toolbar 切换路由，并保持之前缓存 关闭toolbar清除缓存，打开后仍可用缓存 项目源代码https://github.com/slipkinem/vue-admin 实现方式监听路由的变动，当路由改变时将当前路由添加到一个列表里面。循环此列表生成toolbar的tabs，给keep-alive添加两个方法。第一个是当keep-alive工作的时候，设置存储key的hook、第二个方法添加通过key删除缓存removeCacheByKey。当点击关闭按钮的时候，调用removeCacheByKey就可以完美解决vue keep-alive无法主动清除缓存的问题了。主要的keep-alive代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import _ from 'lodash'function isDef (val) &#123; return val !== undefined &amp;&amp; val !== null&#125;function getFirstComponentChild (children) &#123; if (Array.isArray(children)) &#123; for (let i = 0; i &lt; children.length; i++) &#123; const c = children[i] if (isDef(c) &amp;&amp; isDef(c.componentOptions)) &#123; return c &#125; &#125; &#125;&#125;function getComponentName (opts) &#123; return opts &amp;&amp; (opts.Ctor.options.name || opts.tag)&#125;function matches (pattern, name) &#123; if (Array.isArray(pattern)) &#123; return pattern.indexOf(name) &gt; -1 &#125; else if (typeof pattern === 'string') &#123; return pattern.split(',').indexOf(name) &gt; -1 &#125; else if (_.isRegExp(pattern)) &#123; return pattern.test(name) &#125; /* istanbul ignore next */ return false&#125;function pruneCache (cache, current, filter) &#123; for (const key in cache) &#123; const cachedNode = cache[key] if (cachedNode) &#123; const name = getComponentName(cachedNode.componentOptions) if (name &amp;&amp; !filter(name)) &#123; if (cachedNode !== current) &#123; pruneCacheEntry(cachedNode) &#125; cache[key] = null &#125; &#125; &#125;&#125;function pruneCacheEntry (vnode) &#123; if (vnode) &#123; vnode.componentInstance.$destroy() &#125;&#125;export default &#123; name: 'pk-keep-alive', props: &#123; include: [], exclude: [], updateComponentsKey: Function &#125;, created () &#123; // vue的keep-alive存储对象 this.cache = Object.create(null) &#125;, // 调用keep-alive组件销毁钩子，组件销毁的时候同时清除缓存 destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache[key]) &#125; &#125;, watch: &#123; include (val) &#123; pruneCache(this.cache, this._vnode, name =&gt; matches(val, name)) &#125;, exclude (val) &#123; pruneCache(this.cache, this._vnode, name =&gt; !matches(val, name)) &#125; &#125;, render () &#123; const vnode = getFirstComponentChild(this.$slots.default) const componentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; // check pattern const name = getComponentName(componentOptions) if (name &amp;&amp; ( (this.include &amp;&amp; !matches(this.include, name)) || (this.exclude &amp;&amp; matches(this.exclude, name)) )) &#123; return vnode &#125; const key = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : '') : vnode.key // 添加获取key的外部hook this.updateComponentsKey &amp;&amp; this.updateComponentsKey(key) if (this.cache[key]) &#123; vnode.componentInstance = this.cache[key].componentInstance &#125; else &#123; this.cache[key] = vnode &#125; vnode.data.keepAlive = true &#125; return vnode &#125;, methods: &#123; // 通过cache的key删除对应的缓存 removeCacheByKey (key) &#123; pruneCacheEntry(this.cache[key]) this.cache[key] = null &#125; &#125;&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://faceplus.top/tags/vue/"},{"name":"tabs","slug":"tabs","permalink":"http://faceplus.top/tags/tabs/"},{"name":"vue-router","slug":"vue-router","permalink":"http://faceplus.top/tags/vue-router/"}]},{"title":"js设计模式笔记-职责链模式","slug":"js设计模式笔记-职责链模式","date":"2017-08-23T09:45:13.000Z","updated":"2017-08-23T09:47:00.911Z","comments":true,"path":"2017/08/23/js设计模式笔记-职责链模式/","link":"","permalink":"http://faceplus.top/2017/08/23/js设计模式笔记-职责链模式/","excerpt":"职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 你去政府部门求人办事过吗？有时候你会遇到过官员踢球推责，你的问题在我这里能解决就解决，不能解决就推卸给另外个一个部门（对象）。至于到底谁来解决这个问题呢？政府部门就是为了可以避免屁民的请求与官员之间耦合在一起，让多个（部门）对象都有可能接收请求，将这些（部门）对象连接成一条链，并且沿着这条链传递请求，直到有（部门）对象处理它为止。","text":"职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 你去政府部门求人办事过吗？有时候你会遇到过官员踢球推责，你的问题在我这里能解决就解决，不能解决就推卸给另外个一个部门（对象）。至于到底谁来解决这个问题呢？政府部门就是为了可以避免屁民的请求与官员之间耦合在一起，让多个（部门）对象都有可能接收请求，将这些（部门）对象连接成一条链，并且沿着这条链传递请求，直到有（部门）对象处理它为止。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 发送请求 * @param data * @param dealType * @param dom */var sendData = function (data, dealType, dom) &#123; var xhr = new XMLHttpRequest(), url = 'getData.php?mod=userInfo' xhr.onload = function (event) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; dealData(xhr.responseText, dealType, dom) &#125; else &#123; // 失败 &#125; &#125; for (var i in data) &#123; url += '&amp;' + i + '=' + data[i] &#125; xhr.open('get', url, true) xhr.send(null)&#125;/** * 处理响应数据 * @param data * @param dealType * @param dom */var dealData = function (data, dealType, dom) &#123; var dataType = Object.prototype.toString.call(data) switch (dealType) &#123; case 'sug': if (dataType === '[object Array]') &#123; return createSug(data, dom) &#125; if (dataType === '[object Object]') &#123; var newData = [] for (var i in data) &#123; newData.push(data[i]) return createSug(newData, dom) &#125; &#125; return createSug([data], dom) break case 'validate': return createValidateResult(data, dom) break &#125;&#125;/** * 提示框组件 * @param data * @param dom */var createSug = function (data, dom) &#123; var len = data.length, html = '' for (var i = 0; i &lt; len; i++) &#123; html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;' &#125; dom.parentNode.getElementsByTagName('ul')[0].innerHTML = html&#125;var createValidateResult = function (data, dom) &#123; dom.parentNode.getElementsByTagName('span')[0].innerHTML = data&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--策略模式","slug":"js设计模式笔记-策略模式","date":"2017-08-22T10:13:14.000Z","updated":"2017-08-22T10:17:19.367Z","comments":true,"path":"2017/08/22/js设计模式笔记-策略模式/","link":"","permalink":"http://faceplus.top/2017/08/22/js设计模式笔记-策略模式/","excerpt":"策略模式 将定义的一组算法封装起来，使其可以相互替换。封装的算法彼此之间独立，不会随着客户端的变化而变化 通过定义算法返回结果，和状态模式不同的是，没有对象的依赖","text":"策略模式 将定义的一组算法封装起来，使其可以相互替换。封装的算法彼此之间独立，不会随着客户端的变化而变化 通过定义算法返回结果，和状态模式不同的是，没有对象的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051~function () &#123; 'use strict' // 实现 var PriceStrategy = (function () &#123; var strategy = &#123; return30: function (price) &#123; return +price + parseInt(price / 100) * 30 &#125;, return50: function (price) &#123; return +price + parseInt(price / 100) * 50 &#125;, percent90: function (price) &#123; return price * 100 * 90 / 10000 &#125;, percent80: function (price) &#123; return price * 100 * 80 / 10000 &#125;, percent50: function (price) &#123; return price * 100 * 50 / 10000 &#125; &#125; function doStrategy (algorithm, price) &#123; return strategy[algorithm] &amp;&amp; strategy[algorithm](price) &#125; doStrategy.addStrategy = function (field, fn) &#123; strategy[field] = fn &#125; return doStrategy &#125;)() // 使用 var price = PriceStrategy('return50', '346.5') console.log(price) // jQuery的animate就是使用策略模式实现的，传入不同的参数，产生不一样的效果 // $('div').animate(&#123; width: '200px' &#125;, 1000, 'linear') // $('div').animate(&#123; width: '200px' &#125;, 1000, 'swing') // 在这个时候需要打6折怎么办？直接去改的话太麻烦,加上addStrategy方法 // 执行 var p = PriceStrategy('percent80', '34343') console.log(p) PriceStrategy.addStrategy('test59', function (price) &#123; return price * 1000000 &#125;) var p = PriceStrategy('test59', '3434') console.log(p)&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--状态模式","slug":"js设计模式笔记-状态模式","date":"2017-08-22T10:11:59.000Z","updated":"2017-08-22T10:12:58.016Z","comments":true,"path":"2017/08/22/js设计模式笔记-状态模式/","link":"","permalink":"http://faceplus.top/2017/08/22/js设计模式笔记-状态模式/","excerpt":"状态模式 当一个对象的内部状态发生改变时，会导致其行为的改变，看起来像是改变了对象 当碰见需要多次判断某一个值得时候，不能确定是否还是会继续添加，就用状态模式，将判断的条件当做对象内部的一种状态","text":"状态模式 当一个对象的内部状态发生改变时，会导致其行为的改变，看起来像是改变了对象 当碰见需要多次判断某一个值得时候，不能确定是否还是会继续添加，就用状态模式，将判断的条件当做对象内部的一种状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990~function () &#123; 'use strict' // 实现 var log = console.log.bind(console) var ResultState = function () &#123; var States = &#123; state0: function () &#123; log('这是第一种情况') &#125;, state1: function () &#123; log('这是第二种情况') &#125;, state2: function () &#123; log('这是第三种情况') &#125;, state3: function () &#123; log('这是第四种情况') &#125; &#125; function show (result) &#123; States['state' + result] &amp;&amp; States['state' + result]() &#125; return &#123; show &#125; &#125; // 调用 ResultState().show(1) ResultState().show(2) /** * 模仿游戏的人物，执行的动作可以看做一种状态，游戏中的人物有时候需要连续执行多个动作 * @constructor */ var MarryState = function () &#123; var _currentState = &#123;&#125;, states = &#123; jump: function () &#123; log('jump') &#125;, move: function () &#123; log('move') &#125;, shoot: function () &#123; log('shoot') &#125;, squat: function () &#123; log('squat') &#125; &#125; var Action = &#123; changeState: function () &#123; var args = [].slice.call(arguments) _currentState = &#123;&#125; if (args.length) &#123; args.forEach(arg =&gt; &#123; _currentState[arg] = true &#125;) &#125; return this &#125;, goes: function () &#123; log('触发一次动作') for (let i in _currentState) &#123; states[i] &amp;&amp; states[i]() &#125; return this &#125; &#125; return &#123; change: Action.changeState, goes: Action.goes &#125; &#125; var marry = new MarryState() marry .change('jump', 'shoot') .goes() .goes() .change('shoot') .goes()&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--观察者模式","slug":"js设计模式笔记-观察者模式","date":"2017-08-22T10:10:32.000Z","updated":"2017-08-22T10:11:39.550Z","comments":true,"path":"2017/08/22/js设计模式笔记-观察者模式/","link":"","permalink":"http://faceplus.top/2017/08/22/js设计模式笔记-观察者模式/","excerpt":"观察者模式 观察者模式又被称作发布-订阅模式，是一种消息机制，依靠事件很容易实现解耦 观察者模式称为js最重要的设计模式都不为过 观察者模式实际是函数的回调，先将函数放入（订阅）容器中，发布的时候从容器中拿出执行","text":"观察者模式 观察者模式又被称作发布-订阅模式，是一种消息机制，依靠事件很容易实现解耦 观察者模式称为js最重要的设计模式都不为过 观察者模式实际是函数的回调，先将函数放入（订阅）容器中，发布的时候从容器中拿出执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051~function () &#123; 'use strict' var log = console.log.bind(console) // 观察者模式实现 var Observer = (function () &#123; var _messages = &#123;&#125; return &#123; regist: function (type, fn) &#123; if (!_messages.hasOwnProperty(type)) &#123; _messages[type] = [fn] &#125; else &#123; [].push.call(_messages[type], fn) &#125; &#125;, fire: function (type, args) &#123; if (!_messages[type]) return var events = &#123; type: type, data: args || &#123;&#125; &#125; _messages[type].forEach(message =&gt; &#123; message.call(this, events.data) &#125;) &#125;, remove: function (type, fn) &#123; if (_messages[type] instanceof Array) &#123; var i = _messages[type].length - 1 for (; i &gt;= 0; i--) &#123; _messages[type][i] === fn &amp;&amp; _messages[type].splice(i, 1) &#125; &#125; &#125; &#125; &#125;) var observer = Observer() var fn = function (bitch) &#123; log('fuck ', bitch) &#125; // 使用 observer.regist('fuck', fn) observer.regist('gun', fn) observer.fire('fuck', '韩梅梅') observer.remove('fuck', fn) observer.fire('fuck', 'dsfdsf') observer.fire('gun', 'fuck')&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--模板方法模式","slug":"js设计模式笔记-模板方法模式","date":"2017-08-22T10:08:50.000Z","updated":"2017-08-22T10:10:07.208Z","comments":true,"path":"2017/08/22/js设计模式笔记-模板方法模式/","link":"","permalink":"http://faceplus.top/2017/08/22/js设计模式笔记-模板方法模式/","excerpt":"模板方法模式 父类定义一组操作骨架，将一些具体的步骤放在子类中，使得子类不改变父类的情况下，实现多元化展现 提供一个基础的弹框，外壳一样，但是里面的内容不一样，这就是模板方法的一种实现","text":"模板方法模式 父类定义一组操作骨架，将一些具体的步骤放在子类中，使得子类不改变父类的情况下，实现多元化展现 提供一个基础的弹框，外壳一样，但是里面的内容不一样，这就是模板方法的一种实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117~function () &#123; 'use strict' function noop () &#123; &#125; /** * alert底层框架 * @param data * @constructor */ var Alert = function (data) &#123; if (!data) return this.content = data.content this.panel = document.createElement('div') this.contentNode = document.createElement('p') this.confirmButton = document.createElement('span') this.closeBtn = document.createElement('b') this.panel.className = 'alert' this.closeBtn.className = 'a-close' this.confirmButton.className = 'a-confirm' this.confirmButton.innerHTML = data.confirm || '确认' this.contentNode.innerHTML = this.content this.success = data.success || noop this.fail = data.fail || noop &#125; Alert.prototype = &#123; init: function () &#123; // 生成提示框 this.panel.appendChild(this.closeBtn) this.panel.appendChild(this.contentNode) this.panel.appendChild(this.confirmButton) document.body.appendChild(this.panel) this.bindEvent() this.show() &#125;, bindEvent: function () &#123; var _this = this this.closeBtn.onclick = function () &#123; _this.fail() _this.hide() &#125; this.confirmButton.onclick = function () &#123; _this.success() _this.hide() &#125; &#125;, hide: function () &#123; this.panel.style.display = 'node' &#125;, show: function () &#123; this.panel.style.display = 'block' &#125; &#125; // 右侧提示框实现 var RightAlert = function (data) &#123; Alert.call(this, data) this.confirmButton.className += ' right' &#125; RightAlert.prototype = new Alert() // 标题提示框 var TitleAlert = function (data) &#123; Alert.call(this, data) this.title = data.title this.titleNode = document.createElement('h3') this.titleNode.innerHTML = this.title &#125; TitleAlert.prototype = new Alert() TitleAlert.prototype.init = function () &#123; this.panel.insertBefore(this.titleNode, this.panel.firstChild) Alert.prototype.init.call(this) &#125; // 以基类的封装继续封装 var CancelAlert = function (data) &#123; TitleAlert.call(this, data) this.cancel = data.cancel this.cancelBtn = document.createElement('span') this.cancelBtn.className = 'cancel' this.cancelBtn.innerHTML = this.cancel || '取消' &#125; // 这里方法重写基础行为，所有继承最基础的类 CancelAlert.prototype = new Alert() CancelAlert.prototype.init = function () &#123; TitleAlert.prototype.init.call(this) this.panel.appendChild(this.cancelBtn) &#125; CancelAlert.prototype.bindEvent = function () &#123; var _this = this TitleAlert.prototype.bindEvent.call(_this) this.cancelBtn.onclick = function () &#123; _this.fail() _this.hide() &#125; &#125; // 使用 new CancelAlert(&#123; title: 'dfasdfsdf', content: 'dsfsdfsdafs', success: function () &#123; log('success') &#125;, fail: function () &#123; log('fail') &#125; &#125;).init()&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--享元模式","slug":"js设计模式笔记-享元模式","date":"2017-08-22T05:23:16.000Z","updated":"2017-08-22T05:45:39.288Z","comments":true,"path":"2017/08/22/js设计模式笔记-享元模式/","link":"","permalink":"http://faceplus.top/2017/08/22/js设计模式笔记-享元模式/","excerpt":"享元模式 运用共享技术有效的支持最大量的细粒度的对象，避免对象间拥有相同的内容造成多余的开销 主要对数据和方法共享分离，将数据和方法分为外部和内部，内部就是共享的，所以提出来这一部分能提高性能 barrat李靖的解释 “享”是共享的意思，“元”指的是元件，也就是小颗粒的东西，享元顾名思义便是共享小部件，很多系统或者程序包含大量对象，但是这些对象绝大多数都是差不多的，除了一些极个别的属性外。在享元模式中有两个比较重要的关键词，内部变量和外部变量；内部变量是可以共享的属性集，而外部变量是对象之间的差异部分，通过相同+不同的方式组合诸多对象，可以有效地节省系统空间，降低内存大小。","text":"享元模式 运用共享技术有效的支持最大量的细粒度的对象，避免对象间拥有相同的内容造成多余的开销 主要对数据和方法共享分离，将数据和方法分为外部和内部，内部就是共享的，所以提出来这一部分能提高性能 barrat李靖的解释 “享”是共享的意思，“元”指的是元件，也就是小颗粒的东西，享元顾名思义便是共享小部件，很多系统或者程序包含大量对象，但是这些对象绝大多数都是差不多的，除了一些极个别的属性外。在享元模式中有两个比较重要的关键词，内部变量和外部变量；内部变量是可以共享的属性集，而外部变量是对象之间的差异部分，通过相同+不同的方式组合诸多对象，可以有效地节省系统空间，降低内存大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182~function () &#123; 'use strict' var Flywight = function () &#123; var created = [] function create () &#123; var dom = document.createElement('div') document.getElementById('container').appendChild(dom) created.push(dom) return dom &#125; return &#123; getDiv: function () &#123; if (created.length &lt; 5) &#123; return create() &#125; else &#123; var div = created.shift() created.push(div) return div &#125; &#125; &#125; &#125; var paper = 0, article = ['fsdfsdafsadf', 'fsdfsdfsdfdsa', 'fdsfsdfsdfasdf', 'fsdfsdfsdafsdafsdaf', 'ffsdfsdfsdafsdafasdfasdf'], num = 5, len = article.length for (var i = 0; i &lt; 5; i++) &#123; if (article[i]) &#123; Flywight.getDiv().innerHTML = article[i] &#125; &#125; document.getElementById('next_page').onclick = function () &#123; if (article.length &lt; 5) &#123; return &#125; var n = ++paper * num % len, j = 0 for (; i &lt; 5; i++) &#123; if (article[n + j]) &#123; Flywight.getDiv().innerHTML = article[n + j] &#125; else if (article[n + j - len]) &#123; Flywight.getDiv().innerHTML = article[n + j - len] &#125; else &#123; Flywight.getDiv().innerHTML = \"\" &#125; &#125; &#125;&#125;()~function () &#123; // 享元方法，其实也就是共享方法 'use strict' var FlyWeight = &#123; moveX: function (x) &#123; this.x = x &#125;, moveY: function (y) &#123; this.y = y &#125; &#125; var Player = function (x, y, c) &#123; this.x = x this.y = y this.color = c &#125; Player.prototype = FlyWeight Player.prototype.changeC = function (c) &#123; this.color = c &#125;&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记-组合模式","slug":"js设计模式笔记-组合模式","date":"2017-08-21T10:33:04.000Z","updated":"2017-08-22T05:43:50.739Z","comments":true,"path":"2017/08/21/js设计模式笔记-组合模式/","link":"","permalink":"http://faceplus.top/2017/08/21/js设计模式笔记-组合模式/","excerpt":"组合模式 层次结构，将部分整合成一个整体，类似DOM tree，所有有节点组合成一个html，使得用户对单个对象和组合的对象具有一致性 有一个整体作为对外的接口，内部组合若干的层次，模块化每个组件","text":"组合模式 层次结构，将部分整合成一个整体，类似DOM tree，所有有节点组合成一个html，使得用户对单个对象和组合的对象具有一致性 有一个整体作为对外的接口，内部组合若干的层次，模块化每个组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241// utilfunction inheritObject (o) &#123; function F () &#123; &#125; F.prototype = o return new F()&#125;function inheritPrototype (subClass, superClass) &#123; let p = inheritObject(superClass.prototype) p.constructor = subClass subClass.prototype = p&#125;// 总类function News () &#123; this.children = [] this.element = null&#125;// 抽象News.prototype = &#123; constructor: 'News', init: function () &#123; throw new Error('please override your method') &#125;, add: function () &#123; throw new Error('please override your method') &#125;, getElement: function () &#123; throw new Error('please override your method') &#125;&#125;// 容器function Container (id, parent) &#123; News.call(this) this.id = id this.parent = parent&#125;inheritPrototype(Container, News)Container.prototype.init = function () &#123; this.element = document.createElement('ul') this.element.id = this.id this.element.className = 'new-container'&#125;Container.prototype.add = function (child) &#123; this.children.push(child) this.element.appendChild(child.getElement()) return this&#125;Container.prototype.getElement = function () &#123; return this.element&#125;Container.prototype.show = function () &#123; this.parent.appendChild(this.element)&#125;// 下一层级的集合类function Item (className) &#123; News.call(this) this.className = className this.init()&#125;inheritPrototype(Item, News)Item.prototype.init = function () &#123; this.element = document.createElement('li') this.element.className = this.className&#125;Item.prototype.add = function (child) &#123; this.children.push(child) this.element.appendChild(child.getElement()) return this&#125;Item.prototype.getElement = function () &#123; return this.element&#125;var NewsGroup = function (className = '') &#123; News.call(this) this.className = className this.init()&#125;inheritPrototype(NewsGroup, News)NewsGroup.prototype.init = function () &#123; this.element = document.createElement('div') this.element.className = this.className&#125;NewsGroup.prototype.add = function (child) &#123; this.children.push(child) this.element.appendChild(child.getElement())&#125;NewsGroup.prototype.getElement = function () &#123; return this.element&#125;var ImageNews = function (url = '', href = '#', className = 'normal') &#123; News.call(this) this.url = url this.href = href this.className = className this.init()&#125;inheritPrototype(ImageNews, News)ImageNews.prototype.init = function () &#123; this.element = document.createElement('a') var img = new Image() img.src = this.url img.href = this.href this.element.appendChild(img) this.element.className = 'image-news ' + this.className this.element.href = this.href&#125;ImageNews.prototype.add = function () &#123;&#125;ImageNews.prototype.getElement = function () &#123; return this.element&#125;var IconNews = function (text = '', href = '#', type = 'video') &#123; News.call(this) this.text = text this.href = href this.type = type this.init()&#125;inheritPrototype(IconNews, News)IconNews.prototype.init = function () &#123; this.element = document.createElement('a') this.element.innerHTML = this.text this.element.href = this.href this.element.className = 'icon ' + this.type&#125;IconNews.prototype.add = function () &#123;&#125;IconNews.prototype.getElement = function () &#123; return this.element&#125;var EasyNews = function (text = '', href = '#') &#123; News.call(this) this.text = text this.href = href this.init()&#125;inheritPrototype(EasyNews, News)EasyNews.prototype.init = function () &#123; this.element = document.createElement('a') this.element.innerHTML = this.text this.element.href = this.href this.element.className = 'text'&#125;EasyNews.prototype.add = function () &#123;&#125;EasyNews.prototype.getElement = function () &#123; return this.element&#125;function TypeNews (text = '', href = '#', type = '', pos = 'left') &#123; News.call(this) this.text = text this.href = href this.type = type this.pos = pos this.init()&#125;inheritPrototype(TypeNews, News)TypeNews.prototype.init = function () &#123; this.element = document.createElement('a') if (this.pos === 'left') &#123; this.element.innerHTML = '[' + this.type + '] ' + this.text &#125; else &#123; this.element.innerHTML = this.text + ' [' + this.type + ']' &#125; this.element.href = this.href this.element.className = 'text'&#125;TypeNews.prototype.add = function () &#123;&#125;TypeNews.prototype.getElement = function () &#123; return this.element&#125;// 层级已经声明，开始组合var news1 = new Container('news', document.body)news1 .add( new Item('normal') .add( new IconNews('fkdsjflksdjflkjsdlkfjlskdjf', '#', 'video') ) ) .add( new Item('normal') .add( new IconNews('[fdsfdsfdsfsdfsdfdasf', '#', 'live') ) ) .add( new NewsGroup('has-img') .add( new ImageNews('img/1.jpg', '#', 'small') ) .add( new EasyNews('dsfdsfsdfdsfsdfd', '#') ) .add( new EasyNews('xxxxxxxxxxxxxx', '#') ) )","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记-桥接模式","slug":"js设计模式笔记-桥接模式","date":"2017-08-21T10:30:40.000Z","updated":"2017-08-22T05:46:13.889Z","comments":true,"path":"2017/08/21/js设计模式笔记-桥接模式/","link":"","permalink":"http://faceplus.top/2017/08/21/js设计模式笔记-桥接模式/","excerpt":"","text":"桥接模式 某些类型由于自身的逻辑，会向多个维度变化，使其不增加复杂度并达到解耦的目的 将一个函数或者类当做一个桥梁，提取公共部分，将实现和抽象通过桥接的方法链接在一起 针对多维度变化，可以创建许多个桥梁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758'use strict'let log = console.log.bind(console)function Speed (x, y) &#123; this.x = x this.y = y&#125;Speed.prototype.run = function () &#123; log('run')&#125;function Color (cl) &#123; this.cl = cl&#125;Color.prototype.draw = function () &#123; log('draw')&#125;function Shape (sp) &#123; this.shape = sp&#125;Shape.prototype.change = function () &#123; log('改变形状')&#125;function Speek (word) &#123; this.word = word&#125;Speek.prototype.say = function () &#123; log('fuck')&#125;// 创建一座桥梁，在生成 Ball的时候直接 new Ballfunction Ball (x, y, c) &#123; this.speed = new Speed(x, y) this.color = new Color(c)&#125;Ball.prototype.init = function () &#123; this.speed.run() this.color.draw()&#125;function People (x, y, f) &#123; this.speed = new Speed(x, y) this.speek = new Speek(f)&#125;People.prototype.init = function () &#123; this.speed.run() this.speek.say()&#125;// 通过桥梁生成实体var ball = new Ball(1, 2, '#ccc')ball.init()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--装饰者模式","slug":"js设计模式笔记-装饰者模式","date":"2017-08-18T07:44:41.000Z","updated":"2017-08-22T05:45:11.094Z","comments":true,"path":"2017/08/18/js设计模式笔记-装饰者模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-装饰者模式/","excerpt":"","text":"##装饰者模式 不改变原对象的基础上，通过添加属性或方法使原对象满足要求1234567891011121314151617181920212223242526272829'use strict'// 装饰者var decorator = (function () &#123; return function (input, fn) &#123; // 获取事件源 var input = document.getElementById(input) if (typeof input.onclick === 'function') &#123; // 将之前的存起来，那之前有很多怎么办 var old = input.onclick input.onclick = function () &#123; old() // 看见吗就是执行了之前的函数，顺便加了个回调 fn() &#125; &#125; else &#123; input.onclick = fn &#125; // do something &#125;&#125;())document.getElementById('btn').onclick = function() &#123; console.log('fuck')&#125;decorator('btn', function() &#123; console.log('just go on')&#125;)","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--代理模式","slug":"js设计模式笔记-代理模式","date":"2017-08-18T07:43:09.000Z","updated":"2017-08-22T06:27:06.721Z","comments":true,"path":"2017/08/18/js设计模式笔记-代理模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-代理模式/","excerpt":"","text":"代理模式 对于一个对象不能直接引用另一个对象，所以通过代理起个中介作用 没想到这一章讲的是跨域，我的妈呀，这怎么成了设计模式了 跨域解决方案： jsonp 创建script标签获取数据，不能post iframe 通过iframe拿数据，写起来麻烦，还很弱 nginx或者其他服务器进行跨域，或者设置http cors … 其他","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--适配器模式","slug":"js设计模式笔记-适配器模式","date":"2017-08-18T07:41:20.000Z","updated":"2017-08-18T07:42:54.617Z","comments":true,"path":"2017/08/18/js设计模式笔记-适配器模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-适配器模式/","excerpt":"","text":"适配器模式 什么是适配器，就是将数据转化了一下，防止出错或者数据改变 假设引入了JQ，而JQ和自己的代码库重叠了，怎么办？ window.my$ = jQuery 就是这么粗暴 比如你要的数据是[{},{}]这样的，后台给了你{}，你怎么办 写个适配器，转化一下。 噗！吐血","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--外观模式","slug":"js设计模式笔记-外观模式","date":"2017-08-18T07:40:23.000Z","updated":"2017-08-22T05:46:13.903Z","comments":true,"path":"2017/08/18/js设计模式笔记-外观模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-外观模式/","excerpt":"","text":"外观模式 这章坑爹，就是说了下兼容性的封装，在写个小小型代码库 12345678910'use strict'var A = (function () &#123; var o = &#123; g: function (id) &#123; return document.getElementById(id) &#125; &#125; // todo: 其余不想写了，就是获取元素，添加事件的封装 return o&#125;())","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--单例模式","slug":"js设计模式笔记-单例模式","date":"2017-08-18T07:38:50.000Z","updated":"2017-08-22T05:45:45.640Z","comments":true,"path":"2017/08/18/js设计模式笔记-单例模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-单例模式/","excerpt":"","text":"单例模式 只能实例化一次，第二次实例化将之前实例化好的对象返回，就可以共享实例的内存，可用于modal弹框 12345678910111213141516171819202122232425262728'use strict'var single = (function () &#123; var instance = null function Fuck (bitch) &#123; this.bitch = bitch &#125; Fuck.prototype.start = function () &#123; return this.bitch &#125; return &#123; getInstance: function (bitch) &#123; if (!instance) &#123; instance = new Fuck(bitch) &#125; return instance &#125; &#125;&#125;)()// 共享一个实例var s = single.getInstance('fucker')console.log(s)var y = single.getInstance('dsfsd')console.log(y)console.log(y.start())","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--原型模式","slug":"js设计模式笔记-原型模式","date":"2017-08-18T07:38:01.000Z","updated":"2017-08-18T07:38:38.977Z","comments":true,"path":"2017/08/18/js设计模式笔记-原型模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-原型模式/","excerpt":"","text":"受不了了，什么都是设计模式，一个JS的原型链继承都能当做设计模式，也是醉了 整篇我看最有用的就是那个继承函数 说白了这个模式就像将原型的属性和方法进行共享","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--建造者模式","slug":"js设计模式笔记-建造者模式","date":"2017-08-18T07:36:51.000Z","updated":"2017-08-22T05:46:13.874Z","comments":true,"path":"2017/08/18/js设计模式笔记-建造者模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-建造者模式/","excerpt":"","text":"建造者模式 创建出来的对象直接具有已实现的某些属性方法 此模式参与对象的创建过程，干涉了对象的创建细节 场景：已有内部给定的方法和属性，只需要选择需要的属性，就可以产生一个完整的对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576~function () &#123; 'use strict' var Human = function (param) &#123; this.skill = param &amp;&amp; param.skill || '保密' this.hobby = param &amp;&amp; param.hobby || '保密' &#125; Human.prototype = &#123; getSkill: function () &#123; return this.skill &#125;, getHobby: function () &#123; return this.hobby &#125; &#125; var Named = function (name) &#123; var _this = this // 构造 ~function (name, _this) &#123; _this.wholeName = name if (name.indexOf(' ') &gt; -1) &#123; _this.firstName = name.slice(0, name.indexOf(' ')) _this.secondName = name.slice(name.indexOf(' ')) &#125; &#125;(name, _this) &#125; var Work = function (work) &#123; var _this = this ~function (work, _this) &#123; switch (work) &#123; case 'code': _this.work = '工程师' _this.workDescript = '每天沉醉于编程' break case 'UI': case 'UE': _this.work = '设计师' _this.workDescript = '设计更似一种艺术' break case 'teach': _this.work = '教师' _this.workDescript = '分享也是一种快乐' break default: _this.work = work _this.workDescript = '不清楚你的职业' &#125; &#125;(work, _this) &#125; Work.prototype.changeWork = function (work) &#123; this.work = work &#125; Work.prototype.changeDescript = function (descript) &#123; this.workDescript = descript &#125; var Person = function (name, work) &#123; var _person = new Human() _person.name = new Named(name) _person.work = new Work(work) return _person &#125; var person = new Person('s b', 'UI') console.log(person.skill) console.log(person.name.firstName)&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--抽象工厂模式","slug":"js设计模式笔记-抽象工厂模式","date":"2017-08-18T07:35:43.000Z","updated":"2017-08-22T05:46:13.921Z","comments":true,"path":"2017/08/18/js设计模式笔记-抽象工厂模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-抽象工厂模式/","excerpt":"","text":"抽象工厂模式 抽象类：声明但是不能使用的类 创造一个通用的大类，通过这个类去创建一系列抽象类，让子类去继承父类定义的但不能使用的方法,子类然后去实现这个抽象的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384~function (global) &#123; 'use strict' var Car = function () &#123; &#125; Car.prototype = &#123; getPrice: function () &#123; return new Error('抽象方法不能调用') &#125;, getSpeed: function () &#123; return new Error('抽象方法不能调用') &#125; &#125; // 抽象工厂方法 var VehicleFactory = function (subType, superType) &#123; if (typeof VehicleFactory[superType] === 'function') &#123; // noinspection JSAnnotator function F () &#123; &#125; F.prototype = new VehicleFactory[superType]() subType.constructor = subType // 子类原型继承父类 subType.prototype = new F() &#125; else &#123; throw new Error('未创建该抽象对象') &#125; &#125; VehicleFactory.Car = function () &#123; this.type = 'car' &#125; VehicleFactory.Car.prototype = &#123; getPrice: function () &#123; return new Error('抽象方法不能调用') &#125;, getSpeed: function () &#123; return new Error('抽象方法不能调用') &#125; &#125; VehicleFactory.Bus = function () &#123; this.type = 'bus' &#125; VehicleFactory.Bus.prototype = &#123; getPrice: function () &#123; return new Error('抽象方法不能调用') &#125;, getSpeed: function () &#123; return new Error('抽象方法不能调用') &#125; &#125; VehicleFactory.Truck = function () &#123; this.type = 'truck' &#125; VehicleFactory.Truck.prototype = &#123; getPrice: function () &#123; return new Error('抽象方法不能调用') &#125;, getSpeed: function () &#123; return new Error('抽象方法不能调用') &#125; &#125; var BMW = function (price, speed) &#123; this.price = price this.speed = speed &#125; VehicleFactory(BMW, 'car') BMW.prototype.getPrice = function () &#123; return this.price &#125; BMW.prototype.getSpeed = function () &#123; return this.speed &#125;&#125;(this)","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--工厂模式","slug":"js设计模式笔记-工厂模式","date":"2017-08-18T07:33:04.000Z","updated":"2017-08-22T05:46:13.956Z","comments":true,"path":"2017/08/18/js设计模式笔记-工厂模式/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-工厂模式/","excerpt":"","text":"工厂模式 工厂模式顾名思义就是一个工厂，里面可以创建各种类型的产品 工厂模式和类 工厂模式可以根据所需产生不同的类 类是一个厂内一个小型的团体 抽象工程模式 父类不提供实体方法，只提供接口，通过子类去实现覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960'use strict'const log = console.log.bind(console)log('--------简单工厂，就是一个简单的封装--------')~function () &#123; function Button (type, placeholder) &#123; let o = Object.create(null) o.content = placeholder o.click = function () &#123; log(placeholder) &#125; if (type === 'error') &#123; o.color = 'red' &#125; else &#123; o.color = 'blue' &#125; return o &#125; var errorBtn = Button('error', 'heheheheh') var primaryBtn = Button('df', 'dfsdfsdfsdfd') log(errorBtn.content) log(primaryBtn.content)&#125;()log('-------工厂方法模式---------')~function () &#123; function Button (type, content) &#123; if (this instanceof Button) &#123; var o = new this[type](content) return o &#125; else &#123; return new Button(type, content) &#125; &#125; Button.click = function (content) &#123; log(content) &#125; Button.prototype = &#123; constructor: 'Button', error: function (content) &#123; this.color = 'red' Button.click(content) &#125;, primary: function (content) &#123; this.color = 'blue' Button.click(content) &#125; &#125; var a = Button('error', 'content') log(a.color)&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--面向对象","slug":"js设计模式笔记-面向对象","date":"2017-08-18T07:29:39.000Z","updated":"2017-08-22T05:45:30.151Z","comments":true,"path":"2017/08/18/js设计模式笔记-面向对象/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-面向对象/","excerpt":"","text":"##面向对象 面向对象就是将需要的功能封装为一个对象，这个对象称之为类，台湾翻译为面向物体编程，个人认为比较确切 面向对象的特征 封装（就是将私有变量方法封装，高内聚低耦合） 继承（子类继承父类），即一个类继承另一个类的属性和方法 多态（根据函数的参数等不一样的状态，构成不一样的方法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171'use strict'let log = console.log.bind(console)log('----------------------封装，主要是封装私有变量-----------------------')let Book = function (id, name, price) &#123; /** * 私有变量 * @type &#123;number&#125; * @private */ let _num = 1 let _this = this this.id = id this.name = name this.price = price /** * 私有方法 */ function checkId () &#123; log(_this.id, _num, _this.price) &#125; checkId() // 公共方法 this.id = id&#125;// 类静态共有属性Book.face = 'paper'// 静态方法Book.fuck = function () &#123; log('fuck')&#125;// 通过闭包实现封装let Book2 = (function () &#123; // 通过闭包，将属性包起来 /** * 静态变量 * @type &#123;number&#125; * @private */ let _num = 2 return function (id, name) &#123; this.name = name this.fuck = function () &#123; log(this.name, _num) &#125; &#125;&#125;)()let b = new Book2(1, 'test')b.fuck()log('-----------------------继承--------------------------')log('-------类式继承, 引用类型容易和父级绑定到一起，导致问题--------')~function () &#123; let SuperClass = function () &#123; this.superValue = true this.books = [1, 2, 3, 4] &#125; SuperClass.prototype.getSuperValue = function () &#123; return this.superValue &#125; function SubClass () &#123; this.subValue = false &#125; SubClass.prototype = new SuperClass() SubClass.prototype.getSubValue = function () &#123; return this.subValue &#125; SubClass.prototype.setBook = function () &#123; this.books.push('setBook') &#125; let s = new SubClass() let o = new SubClass() log('subValue = ' + o.getSubValue(), 'superValue = ' + o.getSuperValue()) o.setBook() s.books.push('jejejej') log(o.books, s.books)&#125;()log('------构造继承-----')~function () &#123; function SuperClass (id) &#123; this.books = [1, 2, 3] this.id = id &#125; SuperClass.prototype.showBooks = function () &#123; log(this.books) &#125; function SubClass (id) &#123; // 关键 SuperClass.call(this, id) &#125; SubClass.prototype = new SuperClass() let o1 = new SubClass(1) let o2 = new SubClass(2) o1.books.push('34') o2.books.push('43') o1.showBooks() o2.showBooks()&#125;()log('------原型继承-----')~function () &#123; function inheritObject (o) &#123; function F () &#123; &#125; F.prototype = o return new F() &#125; function inheritPrototype (subClass, superClass) &#123; let p = inheritObject(superClass.prototype) p.constructor = subClass subClass.prototype = p &#125; function SuperClass (name) &#123; this.name = name this.colors = [1, 2, 2, 3] &#125; SuperClass.prototype.getName = function () &#123; return this.name &#125; function SubClass (name, time) &#123; // 会开辟内存，构造函数式继承 SuperClass.call(this, name) this.time = time &#125; inheritPrototype(SubClass, SuperClass) SubClass.prototype.getTime = function () &#123; return this.time &#125; let o1 = new SubClass('23', 3434) let o2 = new SubClass('234', 34) o1.colors.push('dsfdsf') log(o1.colors, o2.colors) o1.getName = function () &#123; log('324234324') &#125; o1.getName() log(o2.getName())&#125;()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"js设计模式笔记--简介","slug":"js设计模式笔记-简介","date":"2017-08-18T07:27:18.000Z","updated":"2017-08-22T05:46:13.939Z","comments":true,"path":"2017/08/18/js设计模式笔记-简介/","link":"","permalink":"http://faceplus.top/2017/08/18/js设计模式笔记-简介/","excerpt":"","text":"##创建函数比较多的时候应该加上命名空间 可以写在一个对象里面，也可以用构造函数的方式 链式调用就是返回一个拥有某个方法的对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'use strict'// 1. 真假对象链式调用var CheckObject = function () &#123; var o = &#123; checkName: function () &#123; console.log('name') return o &#125;, checkEmail: function () &#123; console.log('email') return o &#125;, checkPassword: function () &#123; console.log('password') return o &#125; &#125; return o&#125;var checkObject = CheckObject()checkObject.checkName().checkEmail().checkPassword()console.log('-----------------------addMethod-------------------------')// addMethod添加多个函数Function.prototype.addMethod = function (methods) &#123; Object.keys(methods).forEach((key, index) =&gt; &#123; this[key] = methods[key] &#125;) return this&#125;var methods = function () &#123;&#125;methods .addMethod(&#123; 'checkName': function () &#123; console.log('name') return this &#125;, 'checkPassword': function () &#123; console.log('password') return this &#125; &#125;) .addMethod(&#123; 'checkEmail': function () &#123; console.log('email') return this &#125; &#125;)methods.checkName().checkPassword().checkEmail()","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"},{"name":"js基础","slug":"js基础","permalink":"http://faceplus.top/tags/js基础/"}]},{"title":"说说HTTP缓存","slug":"说说HTTP缓存","date":"2017-08-18T01:38:17.000Z","updated":"2017-10-30T07:15:49.625Z","comments":true,"path":"2017/08/18/说说HTTP缓存/","link":"","permalink":"http://faceplus.top/2017/08/18/说说HTTP缓存/","excerpt":"浏览器缓存什么是浏览器缓存用户访问页面的时候，对于某些资源，会将其保存在客户端。在下一次访问的时候，会将缓存从客户端拿出来，减少HTTP请求，提高用户体验。 浏览器缓存是什么样子的？访问github.com，看下资源文件的报文","text":"浏览器缓存什么是浏览器缓存用户访问页面的时候，对于某些资源，会将其保存在客户端。在下一次访问的时候，会将缓存从客户端拿出来，减少HTTP请求，提高用户体验。 浏览器缓存是什么样子的？访问github.com，看下资源文件的报文 可以看到报文里面有cache-control，Expires,Last-Modified这样的字段，这种文件就是从浏览器缓存中拿出来的，可以看出速度特别快 是什么控制着浏览器对文件的缓存与否？Cache-Control: max-age 设置缓存时间，单位为秒，这个时间是指缓存的时长，即在这个时间内的这个资源都会使用这个版本，服务器文件变化了浏览器也不会改变。 public 如果没有指定，则缺省值是public，指定是浏览器或者任何web的代理中间trunk都可以进行文件的缓存，比如CDN也能缓存 private 只有用户浏览器可以缓存，这样CDN中继就缓存不到了 no-cache 表明必须要和服务器进行确认资源是否更改，如果更改了，就会返回最新的，在浏览器NetWork界面激活Disable cache，或者使用ctrl+f5强制刷新，浏览器都会给请求加上Cache-Control:no-cache;Pragma:no-cache no-store 绝对性的禁止掉缓存，比no-cache强势一百倍，直接从服务器拉取资源 其他的都不太常用，就不赘述了 ExpiresExpires是有效期的意思，顾名思义就是设置资源的有效时间，（Expires:Sat, 26 Aug 2017 10:24:11 GMT即只保存到2017-08-26 10:24:11,过时过期），和max-age有点类似，但是没有Cache-Control的优先级高，同时出现Cache-Control:max-age会覆盖掉Expires。Expires需要和last-modified结合使用 Last-modified&nbsp;&nbsp;&nbsp;&nbsp;服务器资源的最后修改时间，需要cache-control共用。浏览器第一请求时，会返回Last-Modified:Wed, 21 Jun 2017 10:03:54 GMT，指服务端最后一次修改文件的时间。浏览器读取后存到这个信息，在下次请求时会给请求头加上If-Modified-Since:Wed, 21 Jun 2017 10:03:54 GMT，用这个值去和服务端对比，没有修改就返回304，如果修改过就返回最新资源。 ETag&nbsp;&nbsp;&nbsp;&nbsp;由服务端根据内容生成的一段hash，浏览器会拿这段hash和服务端进行验证资源是否修改（ETag:&quot;7c9570c4fd0d21:0&quot;）。请求时，浏览器会加上这段ETag，不过请求的字段叫做If-None-Match:W/&quot;7c9570c4fd0d21:0&quot;这就是ETag使用ETag可以解决Last-modified存在的一些问题： 某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒 一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。 同样是200 from disk cache 和 from memory cache 区别可以看到from memory cache是不需要时间的0ms，而memory需要时间。哈哈很简单，就是一个存在disk（磁盘中），一个存在memory(内存)中，存在磁盘需要读取时间。存在磁盘中，退出浏览器资源还会存在，存在memory中关闭浏览器进程就会清除缓存。参考链接memoryCache和diskCache流程详解 都特么几乎是后台控制的缓存，那前端呢？ html页面配置no-cache,html &lt;meta&gt;标签中有个叫做http-equiv的属性，就是设置http头信息，关键字等等 &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;设置no-cache &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 设置Expires为0 … 对于js或者css文我们一般会选择进行缓存，如果要更新的话，只需要将引入的js文件写上版本号1&lt;script src=\"xxx?v=0.2\"&gt;&lt;/script&gt; 最好的方式是给文件加上hash或md5值，对于改变了的文件更改hash，这样就能更新网站了。webpack,gulp等工具都能实现。thx 博客中比较流行的缓存流程图 cache-control","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://faceplus.top/tags/http/"},{"name":"缓存","slug":"缓存","permalink":"http://faceplus.top/tags/缓存/"}]},{"title":"读书整理","slug":"读书整理","date":"2017-08-17T08:10:00.000Z","updated":"2017-08-17T08:31:03.613Z","comments":true,"path":"2017/08/17/读书整理/","link":"","permalink":"http://faceplus.top/2017/08/17/读书整理/","excerpt":"","text":"导言总觉得自己看书看的很乱，总结下看过的书和想看的书，避免看重复，最好做下笔记。看完一本及时更新下，读书笔记都会写在这里。看书总有一种看过了就忘记了，看过了还是不会的感觉，所有看书一定要做好笔记，哪怕记不住，没看懂。将不懂得名词通过搜索引擎查找，哪怕一个词背后有庞大的知识群体，也要硬着头皮看，会有意想不到的收货。读书有一个明显的好处就是可以提高理解能力，读书的时候用心去思考，结合书中的例子将代码一点点敲下来，这是我以后读书要做的事情，之前没做好读书笔记真是太后悔了。keep it real. 正在看的书籍 javascript权威指南 《《HTML5 Canvas游戏开发实战》》 webkit技术内幕 看过得书籍 angular权威指南 angular2 training 深入浅出node.js node.js in action 架构探险 从零开始写javaweb框架 javascript编码规范 你不知道的JavaScript第一卷 一个月悟透javaScript 图解HTTP协议 jsp&amp;servlet学习笔记 想要看的书籍 WEBGL权威指南 C++primary","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"课外学习","slug":"课外学习","permalink":"http://faceplus.top/tags/课外学习/"},{"name":"书籍","slug":"书籍","permalink":"http://faceplus.top/tags/书籍/"}]},{"title":"jsDemo","slug":"jsDemo","date":"2017-07-08T07:13:51.000Z","updated":"2018-03-05T09:30:59.944Z","comments":true,"path":"2017/07/08/jsDemo/","link":"","permalink":"http://faceplus.top/2017/07/08/jsDemo/","excerpt":"","text":"##Demo Demo就在这里","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"demo","slug":"demo","permalink":"http://faceplus.top/tags/demo/"}]},{"title":"简单的代码，读懂观察者模式和Promise","slug":"简单的代码，了解观察者模式和Promise","date":"2017-06-10T12:10:35.000Z","updated":"2017-08-17T08:04:56.954Z","comments":true,"path":"2017/06/10/简单的代码，了解观察者模式和Promise/","link":"","permalink":"http://faceplus.top/2017/06/10/简单的代码，了解观察者模式和Promise/","excerpt":"观察者模式观察者模式又叫做发布订阅模式，其基础支撑是事件的发布与订阅。– 基于观察者模式，可以做数据的绑定，代码的解耦。","text":"观察者模式观察者模式又叫做发布订阅模式，其基础支撑是事件的发布与订阅。– 基于观察者模式，可以做数据的绑定，代码的解耦。 一个简单的观察者模式代码示例：12345678910111213141516171819function Observer() &#123; // 容器，存放subscribe订阅的内容 this.subscribes = &#123; &#125;&#125;Observer.prototype = &#123; constructor: 'Observer', // 往容器放东西 subscribe: function (eventName, callback) &#123; this.subscribes[eventName] = callback &#125;, // 取函数，执行 publish: function (eventName, stuff) &#123; // 把订阅的东西取出来 // 执行 this.subscribes[eventName](stuff) &#125;&#125; 使用此代码123456789var observer = new Observer()observer.subscribe('吃饭', function (stuff) &#123; console.log(stuff) // 成功打印面条&#125;)setTimeout(function () &#123; observer.publish('吃饭', '面条')&#125;, 2000) 代码的逻辑很简单 subscribe的时候将要执行的函数放入存放函数的容器 publish的时候根据事件的名称取出函数，并传入数据，执行 PromisePromise是js异步的解决方案，通常用于ajax请求继续编写简单的代码1234567891011121314151617181920function Promise(executor) &#123; // 容器，存放then订阅的东西 this._deferreds = [] var _this = this // 承诺被执行 function resolve(stuff) &#123; // 取出存的东西 _this._deferreds.forEach(function (deferred) &#123; // 执行 deferred(stuff) &#125;) &#125; // Promise传入的函数，执行时将resolve传进去 executor(resolve)&#125;Promise.prototype.then = function (onFulfilled) &#123; // 往里面放东西 this._deferreds.push(onFulfilled)&#125; 使用此代码12345678new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve('apple') &#125;, 2000)&#125;) .then(function (stuff) &#123; console.log(stuff) // apple &#125;) Promise的关键点在于 .then是给存放回调的容器里面添加回调函数 resolve是then注册回调的执行者，所以当异步的时候，then要后于resolve执行。同样PubSub也可以用于异步 Promise也是观察者模式的一种实现12345678910111213// 使用事件发布订阅处理异步var observer = new Observer()observer.subscribe('吃饭', function (stuff) &#123; console.log(stuff) // 面条&#125;)$.ajax(&#123; url: '饭堂'&#125;).success(function(data) &#123; observer.publish('吃饭', data['面条'])&#125;) 都可以轻松的实现异步的解耦以上都是最简单的实现，二八定律中的二吧，有兴趣可以用es6写一个简单版的Promisees6Promise","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"基础知识","slug":"基础知识","permalink":"http://faceplus.top/tags/基础知识/"}]},{"title":"angular2-约定优于配置","slug":"angular2-约定优于配置","date":"2017-05-15T09:46:33.000Z","updated":"2017-05-15T09:53:43.970Z","comments":true,"path":"2017/05/15/angular2-约定优于配置/","link":"","permalink":"http://faceplus.top/2017/05/15/angular2-约定优于配置/","excerpt":"angular2可以明显感觉到一个法则：约定优于配置","text":"angular2可以明显感觉到一个法则：约定优于配置","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://faceplus.top/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://faceplus.top/tags/typescript/"}]},{"title":"java SSM和vue整合","slug":"java-ssm","date":"2017-04-25T06:18:45.000Z","updated":"2017-08-22T06:41:58.601Z","comments":true,"path":"2017/04/25/java-ssm/","link":"","permalink":"http://faceplus.top/2017/04/25/java-ssm/","excerpt":"SSM整合流程spring spring-mvc mybatis maven web前端项目的源码vue-admin 数据库的sql文件vue_admin.sql IDE idea File =&gt; new Project =&gt; maven =&gt; create from archetype =&gt; maven-archetype-webapp 一直点击next直到finished，maven会自动创建一个项目目录 最终项目目录结构图","text":"SSM整合流程spring spring-mvc mybatis maven web前端项目的源码vue-admin 数据库的sql文件vue_admin.sql IDE idea File =&gt; new Project =&gt; maven =&gt; create from archetype =&gt; maven-archetype-webapp 一直点击next直到finished，maven会自动创建一个项目目录 最终项目目录结构图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475│ .gitignore│ pom.xml│ README.md│ tree.txt│ ├─src│ └─main│ ├─java│ │ └─cn│ │ └─lvsen│ │ └─test│ │ ├─controller│ │ │ TableController.java│ │ │ UserController.java│ │ │ │ │ ├─dao│ │ │ TableDataMapper.java│ │ │ UserMapper.java│ │ │ │ │ ├─interceptor│ │ │ AuthInterceptor.java│ │ │ │ │ ├─mapping│ │ │ TableDataMapper.xml│ │ │ UserMapper.xml│ │ │ │ │ ├─model│ │ │ TableData.java│ │ │ TableDataExample.java│ │ │ User.java│ │ │ UserExample.java│ │ │ │ │ └─service│ │ │ TableService.java│ │ │ UserService.java│ │ │ │ │ └─impl│ │ TableServiceImpl.java│ │ UserServiceImpl.java│ │ │ ├─resources│ │ │ generatorConfig.xml│ │ │ jdbc.properties│ │ │ logback.xml.bak│ │ │ │ │ └─spring│ │ spring-mvc.xml│ │ spring-mybatis.xml│ │ │ └─webapp│ │ index.html│ │ index.jsp│ │ │ ├─static│ │ ├─css│ │ │ app.f3c8e005c2be0a746136766675898059.css│ │ │ app.f3c8e005c2be0a746136766675898059.css.gz│ │ │ │ │ ├─fonts│ │ │ element-icons.b02bdc1.ttf│ │ │ │ │ └─js│ │ 0.105cd4667842b0092158.js│ │ 1.3f78774435db7aa5de2a.js│ │ app.3ec6fa4bebfb1bb58a2b.js│ │ app.3ec6fa4bebfb1bb58a2b.js.gz│ │ manifest.b0bb778337a7d07c6313.js│ │ vendor.bbf93d5282d3216eb30e.js│ │ vendor.bbf93d5282d3216eb30e.js.gz│ │ │ └─WEB-INF│ web.xml│ └─test TestHello.java 在创建的POM里面添加依赖 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;article&lt;/groupId&gt; &lt;artifactId&gt;article&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;article Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 事务管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring测试用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注解扫描 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 切面，将日志记录，事务等分离开来 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis和spring结合用 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 转换json用 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson转换json用 @ResponseBody默认调用jackson，将java对象转为json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- javaHttp基础包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j要配合其他日志包运行，slf4j起个管理的作用 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;article&lt;/finalName&gt; &lt;!-- 防止package打包不到XML--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!-- mybatis生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;!-- 生成文件的配置 --&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- maven插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置mybatisGeneratorConfig，需要连接数据库， 将准备的sql文件导入数据库中vue_admin.sqlgeneratorConfig.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--&lt;properties resource=\"jdbc.properties\"/&gt;--&gt; &lt;!--连接mysql的jar包--&gt; &lt;classPathEntry location=\"C:/Users/**/.m2/repository/mysql/mysql-connector-java/5.1.29/mysql-connector-java-5.1.29.jar\" /&gt; &lt;context id=\"default\" targetRuntime=\"MyBatis3\"&gt; &lt;!-- jdbc连接 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/vue_admin\" userId=\"**\" password=\"**\"/&gt; &lt;!-- 生成model =》 数据层 --&gt; &lt;javaModelGenerator targetPackage=\"cn.lvsen.test.model\" targetProject=\"src/main/java\"&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成mapper 存有mybatis的数据库操作xml --&gt; &lt;sqlMapGenerator targetPackage=\"cn.lvsen.test.mapping\" targetProject=\"src/main/java\"&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 存有mappper的接口类，mybatis会自动生成实体类，将mapper和dao连接起来 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.lvsen.test.dao\" targetProject=\"src/main/java\"&gt; &lt;/javaClientGenerator&gt; &lt;!-- 表的名字 --&gt; &lt;table tableName=\"t_table\" domainObjectName=\"TableData\"/&gt; &lt;table tableName=\"t_user\" domainObjectName=\"User\" /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置resources/spring/spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--扫描包，查注解--&gt; &lt;context:component-scan base-package=\"cn.lvsen.test\"/&gt; &lt;!--映射器与适配器，去掉@ResponseBody就会出问题--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源放置地 --&gt; &lt;mvc:resources mapping=\"/**\" location=\"static\" /&gt; &lt;!--&lt;mvc:resources mapping=\"/css/**\" location=\"static\" /&gt;--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/api/**\"/&gt; &lt;bean class=\"cn.lvsen.test.interceptor.AuthInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 视图 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/\" p:suffix=\".html\"/&gt;&lt;/beans&gt; 配置resources/spring/spring-mybatis.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--引入jdbc的配置文件--&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"classpath:jdbc.properties\" /&gt; &lt;/bean&gt; &lt;!--jdbc连接数据库基本配置--&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/bean&gt; &lt;!--spring和mybatis结合的配置--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath:cn/lvsen/test/mapping/*Mapper.xml\" /&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!--少了这句话会导致空指针异常--&gt; &lt;property name=\"properties\"&gt; &lt;value&gt;&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--dao接口，sping会自动查找其中的类 dao ——&gt; 数据访问层 dao映射的mapper，去掉启动报错--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.lvsen.test.dao\"/&gt; &lt;!--对应上面id=\"sqlSessionFactory\"--&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt;&lt;/beans&gt; spring-mybatis.xml配置时用了jdbc.properties这是为了方便管理连接 resources/jdbc.properties的配置 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/vue_admin?useUnicode=true&amp;characterEncoding=UTF-8jdbc.username=**jdbc.password=** web.xml配置，web.xml是这个web项目的入口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--spring和mybatis的配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--spring监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--解决乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--映射的路径--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 声明静态资源类型，加入spring扫描 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--spring MVC 核心分发器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 首页，可以多个，根据顺来显示--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; SSM基本配置完了，其他功能需要的时候再加，现在新建文件夹 java/cn.xx.xx/controller // controller层 java/cn.xx.xx/service // service层 java/cn.xx.xx/service/impl // service层接口的实现类 webapp/index.html 在controller里面新建一个UserController类，进行restAPI的书写,api使用url: api/user/hello 123456789101112131415161718@Controller@RequestMapping(\"api/user\")public class UserController &#123; @RequestMapping(value = \"hello\", method = RequestMethod.GET) @ResponseBody // 要返回json数据 public Map login(HttpSession httpSession) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); try &#123; map.put(\"errorCode\", 0); map.put(\"message\", \"hello\"); &#125; catch (Exception e) &#123; map.put(\"errorCode\", 1); map.put(\"errorMessage\", \"未知错误\"); &#125; return map; &#125; 一个接口写好，然后配置服务器启动项目1.2.3.然后点击apply =&gt; OK项目启动，打开地址栏，追加输入api/user/hello，拿到数据OK，后台走通 前端部分 后台暂时放置，开始写前端前端部分代码前端框架用的VUE，UI框架用的饿了么开源的element_ui 总概况：vue+vue-router+vue-resource+vuex+element_ui 用npm下载vue-cli 用vue-cli生成webpack项目骨架 npm install 下载所有依赖","categories":[{"name":"课外学习","slug":"课外学习","permalink":"http://faceplus.top/categories/课外学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"java","slug":"java","permalink":"http://faceplus.top/tags/java/"},{"name":"ssm","slug":"ssm","permalink":"http://faceplus.top/tags/ssm/"}]},{"title":"所谓publish-subscribe","slug":"所谓publish-subscribe","date":"2017-04-22T12:14:58.000Z","updated":"2017-05-15T09:47:12.843Z","comments":true,"path":"2017/04/22/所谓publish-subscribe/","link":"","permalink":"http://faceplus.top/2017/04/22/所谓publish-subscribe/","excerpt":"","text":"所谓观察者模式 publish/subscribe subscribe事件订阅/事件监听 就是将事件和事件的callback，添加到一个需要监听执行事件队列里面 { eventName: [callback1, callback1], eventName: [callback] } 接收到publish发布事件就是将subscribe的事件从队列拿出来执行 在外看来就像是一直在监测这个事件，然后接收到publish发布的，执行监测的事件callback","categories":[{"name":"课外学习","slug":"课外学习","permalink":"http://faceplus.top/categories/课外学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://faceplus.top/tags/设计模式/"}]},{"title":"react-native进入姿势","slug":"react-native进入姿势","date":"2017-04-22T03:34:51.000Z","updated":"2017-10-30T10:05:02.673Z","comments":true,"path":"2017/04/22/react-native进入姿势/","link":"","permalink":"http://faceplus.top/2017/04/22/react-native进入姿势/","excerpt":"开始战斗从react到react native, 已经走过许多时间。react native是一个高性能的用javascript开发app的框架。准备学一点react，然后觉得不如直接学习react-native，就开始了react-native之路，从环境搭建到一个小DEMO，花了不少时间，主要是下载太麻烦 准备工作 ide: 我选择idea，习惯了 电脑：win7的i5渣配置，所以先不打算进行ios开发 没有vpn，宽带是交话费送的10M联通宽带，网速还行1m/s 推荐给电脑安装wox和everything(wox插件就有)，方便寻找文件 环境搭建node环境 下载安装nodeJs（最新的就行），为了防止环境变量有问题，不要修改安装目录 使用 node-v npm -v 看看有没有安装成功","text":"开始战斗从react到react native, 已经走过许多时间。react native是一个高性能的用javascript开发app的框架。准备学一点react，然后觉得不如直接学习react-native，就开始了react-native之路，从环境搭建到一个小DEMO，花了不少时间，主要是下载太麻烦 准备工作 ide: 我选择idea，习惯了 电脑：win7的i5渣配置，所以先不打算进行ios开发 没有vpn，宽带是交话费送的10M联通宽带，网速还行1m/s 推荐给电脑安装wox和everything(wox插件就有)，方便寻找文件 环境搭建node环境 下载安装nodeJs（最新的就行），为了防止环境变量有问题，不要修改安装目录 使用 node-v npm -v 看看有没有安装成功 注册淘宝镜像 12&gt; npm config set registry https://registry.npm.taobao.org --global&gt; npm config set disturl https://npm.taobao.org/dist --global 下载yarn，react-native默认使用yarn下载 12&gt; npm i -g yarn&gt; yarn -v 给yarn注册淘宝镜像 12&gt; yarn config set registry https://registry.npm.taobao.org --global&gt; yarn config set disturl https://npm.taobao.org/dist --global react-native安装 使用yarn下载react-native-cli 12&gt; yarn global add react-native-cli&gt; react-native --version 创建项目,一直等待下载完成，生成的目录还是很清晰的 1&gt; react-native init rnDemo 试着运行项目 12&gt; cd rnDemo&gt; npm start 命令行显示，8081端口开启服务。在浏览器输入localhost:8081,显示React Native packager is running.，说明服务还是通畅的。可咱们要做安卓项目！所以继续使用命令行 1&gt; react-native run-android 不出意外会挺慢，因为要下载gradle（gradle是安卓项目常用的构建工具，用来管理jar包和执行任务）和jar包，命令行会提示在此url下载文件Download https://jcenter.bintray.com/com/android/tools/annotations/25.2.3/annotations-25.2.3.jar 因为网络的问题，所以给gradle配置阿里云maven（java常用的包管理工具，有一个下载的仓库，但很慢）镜像。进入.gradle文件夹，一般在C:\\Users\\Administrator\\.gradle，使用wox就简单多了在 .gradle 文件夹里面新建 init.gradle 文件，并写入下面代码，或点击下载init.gradle 1234567891011121314151617allprojects&#123; repositories &#123; def REPOSITORY_URL = 'http://maven.aliyun.com/nexus/content/groups/public/' all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url = repo.url.toString() if (url.startsWith('https://repo1.maven.org/maven2') || url.startsWith('https://jcenter.bintray.com/')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $REPOSITORY_URL.\" remove repo &#125; &#125; &#125; maven &#123; url REPOSITORY_URL &#125; &#125;&#125; 继续运行命令react-native run-android 1&gt; react-native run-android 可以看到下载速度快了好多，但最后会发现报错SDK location not found，这是因为没有安装 android sdk ，接下来配置 android环境 android开发环境配置 安装java环境，搜一下有N多教程 下载android studio 没有翻墙的话推荐使用网盘下载 安装android studio 推荐使用默认安装一直点击next 第一次启动会进入下面界面 standard 标准配置，推荐第一次安装使用能够 custom 选择安装， 可以自己定制安装选项由于是第一此安装就直接选用默认的standard安装，但是react-native官网推荐custom 记得勾选Android Virtual Device，一直next，最后点击finished等待下载完成 环境变量在电脑环境变量设置里面，点击新建，ANDROID_HOME sdk路径然后再到环境变量 path 里面添加类似这样C:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\toolsC:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\platform-tools一定注意路径的正确性 再次运行 运行react-native run-android1&gt; react-native run-android 又提示报错关于 [Android SDK Platform 23, Android SDK Build-Tools 23.0.1].， 这是由于少了build-tools 23.0.1, 在sdk manager里面安装就行了点击finished 运行react-native run-android1&gt; react-native run-android 提示报错com.android.builder.testing.api.DeviceException: No connected devices!, 由于没连上设备导致的错误 连接设备adb（连接devices的驱动）可以通过模拟器和真机进行，android studio带的模拟器不怎么好用，所以我选择用强大的genymotion进行开发 下载genymotion免费版并启动 下载并安装genymotion免费版,替换安装目录文件就免费了 由于genymotion依赖virtualbox，下载安装virtualbox就行了 以上安装好之后打开genymotion，根据提示添加一个设备并运行该安卓模拟器 安装完毕，选择一个添加好的虚拟机，并启动。 糟糕，不知什么原因报错了。碰到这种报错不用怕，打开virtualBox，直接启动安装好的虚拟机。可以看出来是virtualBox的配置有错误，那就打开配置信息跟随黄色提示配置好virtualBox,继续启动在genymotion里面添加的设备，完美! 在genymotion里面配置sdk路径 如果还是提示连接不上设备，就用adb连接一下123&gt; adb devices&gt; adb connect 127.0.0.1&gt; adb devices 开始开发 各种配置都设置好了，继续运行react-native run-android 尼玛又是error,这次明显的看出提示没有连接上js Service,得手动连接了点击菜单 -&gt; Dev Setting -&gt; Debug server host然后返回，reload一下出现成功界面，可以愉快的开发了注意：在菜单里面点击 Enable Hot Reloading，这样就可以保存后实时刷新了 正式开发，就写一个简单的底部导航路由用到底部导航package react-native-tab-navigator1&gt; yarn add react-native-tab-navigator 修改index.android.js,给入口少搁点东西，不然看着恶心12345678import React, &#123; Component &#125; from 'react';import &#123; AppRegistry&#125; from 'react-native';import RootApp from './app/RootApp'AppRegistry.registerComponent('rnDemo', () =&gt; RootApp); // rnDemo是项目的名称 在根目录新建文件夹app，在app里面新建 RootApp.js、components/Home.js、components/Nice.js app/RootApp.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123;Component&#125; from 'react'import &#123; View, StyleSheet&#125; from 'react-native'import TabNavigator from 'react-native-tab-navigator'import Home from './components/Home'import Nice from './components/Nice'import TabNavigatorItem from \"react-native-tab-navigator/TabNavigatorItem\";export default class RootApp extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; selectedTab: 'home' &#125; &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigatorItem title=\"Home\" onPress=&#123;() =&gt; this.setState(&#123;selectedTab: 'home'&#125;)&#125; selected=&#123;this.state.selectedTab === 'home'&#125;&gt; &lt;Home/&gt; &lt;/TabNavigatorItem&gt; &lt;TabNavigatorItem title=\"Nice\" onPress=&#123;() =&gt; this.setState(&#123;selectedTab: 'nice'&#125;)&#125; selected=&#123;this.state.selectedTab === 'nice'&#125;&gt; &lt;Nice/&gt; &lt;/TabNavigatorItem&gt; &lt;/TabNavigator&gt; &lt;/View&gt; ) &#125;&#125;let styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#ccc' &#125;&#125;); app/components/Home.js1234567891011121314import React, &#123;Component&#125; from 'react'import &#123; Text&#125; from 'react-native'export default class Home extends Component &#123; render() &#123; return ( &lt;Text&gt; 我是Home &lt;/Text&gt; ) &#125;&#125; app/components/Nice.js1234567891011121314import React, &#123;Component&#125; from 'react'import &#123; Text&#125; from 'react-native'export default class Nice extends Component &#123; render() &#123; return ( &lt;Text&gt; 我是Nice &lt;/Text&gt; ) &#125;&#125; 大功告成","categories":[{"name":"自学历程","slug":"自学历程","permalink":"http://faceplus.top/categories/自学历程/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"reactNative","slug":"reactNative","permalink":"http://faceplus.top/tags/reactNative/"}]},{"title":"angular-$rootScope.$new()","slug":"angular-rootScope-new","date":"2017-04-22T01:32:15.000Z","updated":"2017-05-15T09:47:12.762Z","comments":true,"path":"2017/04/22/angular-rootScope-new/","link":"","permalink":"http://faceplus.top/2017/04/22/angular-rootScope-new/","excerpt":"","text":"Scope实例上面有这么一个属性：$new()$new(isolate, parent)所有scope都是通过$new创建 参数解释 参数一（isolate）设置是否为孤立作用域 如果是true，则建立孤立作用域，孤立作用域直接和祖级作用域联系 child = new Scope(); child.$root = this.$root 如果是false，则判断此$rootScope有没有子作用域，如果没有则建立一个子作用域构造函数，并且将这个子作用域的原型指向this（$rootScope =&gt; Scope的实例）,然后将child = new this.$$ChildScope() child.__proto__ = Scope.prototype 参数二设置要new的作用域的parent，如果不设置则将parent = this， 也就是将new的child挂载到this(此$rootScope)上面，然后给parent的子作用域排序，有个判断如果设置了isolate并且parent != this`,则作用域不监听$destory事件 e.g:var scope = $rootScope.$new() 没有指定参数，则1.将scope的父级指向$rootScope, 2.将scope创建为$rootScope的子作用域，并在原型上继承$rootScope的所有属性方法，返回。`","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://faceplus.top/tags/angular/"},{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"}]},{"title":"java用jdbc，servelet的一个小问题","slug":"java用jdbc-servelet时的问题","date":"2017-04-21T02:14:19.000Z","updated":"2017-05-15T09:47:12.818Z","comments":true,"path":"2017/04/21/java用jdbc-servelet时的问题/","link":"","permalink":"http://faceplus.top/2017/04/21/java用jdbc-servelet时的问题/","excerpt":"","text":"在用jdbc连接数据库的时候碰见一个tomcat抛得错误，java.lang.ClassNotFoundException: com.mysql.jdbc.Driver ，感觉不对，我已经在idea的Modules里面添加了mysql.jar的包，在测试的时候连接是正常的。原来要将mysql驱动包复制到tomcat的lib文件夹。 在连接驱动包的时候碰见这种写法Class.forName(&quot;com.mysql.jdbc.Driver&quot;)原来这种写法是注册mysql依赖包，等同于DriverManager.registerDriver(new com.mysql.jdbc.Driver()); maven：为了让依赖好管理， mybatis：为了让DML更简单，spring：为了让servlet更好用","categories":[{"name":"exception","slug":"exception","permalink":"http://faceplus.top/categories/exception/"}],"tags":[{"name":"java","slug":"java","permalink":"http://faceplus.top/tags/java/"}]},{"title":"学习计划","slug":"学习计划","date":"2017-04-19T08:23:55.000Z","updated":"2017-04-19T08:34:08.659Z","comments":true,"path":"2017/04/19/学习计划/","link":"","permalink":"http://faceplus.top/2017/04/19/学习计划/","excerpt":"","text":"学习计划清单要强制按照计划来，不然总是盲目的不知道要做什么，感觉茫茫然的 前端部分 react react之前只是粗略的过了一遍，大概知道是什么原理，但没有真正做项目 vue-admin项目的继续扩展 研究bootstrap.js里面插件的实现，争取动手写一套UI插件 后端部分 前端项目的后台全部由java来做，之前node.js写的后台也由java重构，使用java的spring","categories":[],"tags":[{"name":"课外学习","slug":"课外学习","permalink":"http://faceplus.top/tags/课外学习/"}]},{"title":"DOM属性currentTarget","slug":"currentTarget","date":"2017-04-19T07:18:24.000Z","updated":"2017-05-15T09:47:12.790Z","comments":true,"path":"2017/04/19/currentTarget/","link":"","permalink":"http://faceplus.top/2017/04/19/currentTarget/","excerpt":"","text":"1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function getEventTrigger(event) &#123; x=event.currentTarget; console.log(event)console.log(event.currentTarget) &#125;&lt;/script&gt;&lt;/head&gt;&lt;body &gt;&lt;p id=\"p1\" onmousedown=\"getEventTrigger(event)\"&gt;Click on this paragraph. An alert box willshow which element triggered the event.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行此代码会发现： console.log(event) currentTarget:null 而直接打印currentTarget则返回当前节点这是由于打印event的时候currentTarget被重置为null了，用debug查看的话就不会出现null这种情况","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"dom","slug":"dom","permalink":"http://faceplus.top/tags/dom/"}]},{"title":"es6版promise","slug":"es6版promise","date":"2017-04-18T02:34:21.000Z","updated":"2017-08-22T05:47:32.921Z","comments":true,"path":"2017/04/18/es6版promise/","link":"","permalink":"http://faceplus.top/2017/04/18/es6版promise/","excerpt":"es6版Promise用法123456new Promise(function(resolve, reject) &#123; resolve('resolve')&#125;) .then(function(result) &#123; console.log(result) // resolve &#125;) Promise是一个构造函数，接受一个函数作为参数 这个函数接受两个参数： (1) resolve 成功的时候返回的数据 （履行承诺） (2) reject 失败的时候返回的数据 （拒绝承诺） Promise原型方法 (1) then注册成功后的回调 (2) catch注册失败后的回调","text":"es6版Promise用法123456new Promise(function(resolve, reject) &#123; resolve('resolve')&#125;) .then(function(result) &#123; console.log(result) // resolve &#125;) Promise是一个构造函数，接受一个函数作为参数 这个函数接受两个参数： (1) resolve 成功的时候返回的数据 （履行承诺） (2) reject 失败的时候返回的数据 （拒绝承诺） Promise原型方法 (1) then注册成功后的回调 (2) catch注册失败后的回调 上源代码——由于使用es6所以用babel，点击看编译过的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273class util &#123; static isFunction(value) &#123; return typeof value === 'function' &#125; static isArray(value) &#123; return Array.isArray(value) &#125;&#125;/** * Promise * @constructor */class Promise extends util &#123; constructor(executor) &#123; /** * 继承绑定，作为context调用父类的constructor */ super(executor) if (!Promise.isFunction(executor)) throw new TypeError('参数必须是一个函数') /** * @description * 状态分为 PENDING 可以过度到RESOLVED或REJECTED * RESOLVED * REJECTED * @type &#123;string&#125; * @private */ this._status = 'PENDING' /** * 正确值 * @type &#123;Object&#125; * @private */ this._value = Object.create(null) /** * 错误值 * @type &#123;Object&#125; * @private */ this._reason = Object.create(null) /** * 储存错误回调 * @type &#123;Array&#125; * @private */ this._rejecteds = [] /** * 正确回调的方法集 * @type &#123;Array&#125; * @private */ this._deferreds = [] /** * 在class中 constructor里面的函数无法直接访问this * 为了形成private，所以不放外面 * @type &#123;Promise&#125; * @private */ let _this = this /** * 执行承诺的函数 * @param value */ function resolve(value) &#123; /** * 异步，为了让then先执行，注册进回调 */ setTimeout(() =&gt; &#123; try &#123; if (_this._status === 'PENDING') &#123; _this._status = 'RESOLVED' _this._value = value /** * 循环执行所有的回调 */ _this._deferreds.forEach((deferred) =&gt; &#123; deferred(value) &#125;) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125; function reject(reason) &#123; setTimeout(() =&gt; &#123; try &#123; if (_this._status === 'PENDING') &#123; _this._status = 'REJECTED' _this._reason = reason _this._rejecteds.forEach((rejected) =&gt; &#123; rejected(reason) &#125;) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125; try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; /** * resolve方法 * @example Promise.resolve('test').then(function(result)&#123; result // test &#125;) * @param value * @returns &#123;Promise&#125; */ static resolve(value) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(value) &#125;) &#125; /** * all方法 当需要许多promise一起执行的时候用，最后返回一个存有所有promise返回值的数组 * 当一个promise reject掉了，认为此all方法执行失败，进入reject * @param promises * @returns &#123;Promise&#125; */ static all(promises) &#123; if (!Promise.isArray(promises)) throw new TypeError('promises 必须是一个数组') /** * 返回一个Promise */ return new Promise((resolve, reject) =&gt; &#123; let result = [], len = promises.length /** * 将所有的返回值存储起来 * @param value */ function resolveAll(value) &#123; result.push(value) if (--len === 0) &#123; resolve(result) &#125; &#125; promises.forEach(function (promise) &#123; /** * 将成功后的加入result数组 * 一旦有一个失败，则直接返回失败 */ promise.then(resolveAll, reject) &#125;) &#125;) &#125; /** * 方便使用，封装catch方法 * @param onRejected */ catch(onRejected) &#123; this.then(null, onRejected) &#125; /** * 重点方法，then * @param onFulfilled * @param onRejected * @returns &#123;Promise&#125; */ then(onFulfilled, onRejected) &#123; /** * 每次执行then都会返回一个promise供链式调用 */ return new Promise((resolve, reject) =&gt; &#123; let returnedValue = Object.create(null) /** * 如果是RESOLVED状态说明执行了过resolve函数，this.value是有值的 * e.g. Promise.resolve('resolve').then(function(result)&#123;&#125;) * 最主要看onFulfilled返回值是什么 */ /** * _RESOLVED * @param value * @private */ function _RESOLVED(value) &#123; /** * 取得onFulfilled的返回值，判断是否返回一个promise * 回调方式的then * @example * new Promise(function(resolve, reject)&#123; * resolve('test') * &#125;) * .then(function(result)&#123; * return new Promise(function(resolve, reject)&#123; * resolve(result + 'test') * &#125;) * .then() * &#125;) */ returnedValue = Promise.isFunction(onFulfilled) &amp;&amp; onFulfilled(value) || value try &#123; if (returnedValue &amp;&amp; returnedValue instanceof Promise) &#123; returnedValue.then((value) =&gt; &#123; resolve(value) &#125;, (reason) =&gt; &#123; reject(reason) &#125;) &#125; else &#123; resolve(returnedValue) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; /** * 失败的错误 * @param reason * @private */ function _REJECTED(reason) &#123; returnedValue = Promise.isFunction(onRejected) &amp;&amp; onRejected(reason) || reason reject(returnedValue) &#125; /** * 直接调用resolve的情况 * @example * Promise.resolve('test') * .then(function() &#123;&#125;) */ if (this._status === 'RESOLVED') &#123; _RESOLVED(this._value) &#125; else if (this._status === 'REJECTED') &#123; _REJECTED(this._reason) &#125; else if (this._status === 'PENDING') &#123; /** * e.g. new Promise().then(function(result)&#123;&#125;) */ this._deferreds.push(_RESOLVED) this._rejecteds.push(_REJECTED) &#125; &#125;) &#125;&#125;/** * 将类返回，外面用babel编译 * @type &#123;Promise&#125; */module.exports = Promise","categories":[{"name":"小轮子","slug":"小轮子","permalink":"http://faceplus.top/categories/小轮子/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://faceplus.top/tags/es6/"},{"name":"promise","slug":"promise","permalink":"http://faceplus.top/tags/promise/"}]},{"title":"angular权威指南笔记","slug":"angular权威指南学习","date":"2017-04-14T10:37:59.000Z","updated":"2017-05-15T09:47:12.776Z","comments":true,"path":"2017/04/14/angular权威指南学习/","link":"","permalink":"http://faceplus.top/2017/04/14/angular权威指南学习/","excerpt":"angular权威指南笔记 $interpolate——服务插值表达式，可以设置插值表达式中的数据并$interpolateProvider 可以自定义 flag =&gt; $x$ orderBy——排序：给显示的文本排序","text":"angular权威指南笔记 $interpolate——服务插值表达式，可以设置插值表达式中的数据并$interpolateProvider 可以自定义 flag =&gt; $x$ orderBy——排序：给显示的文本排序 $parsers当用户同控制器进行交互，并且ngModelController中的$setViewValue()方法被调用时，$parsers数组中的函数会以流水线的形式被逐个调用。第一个$parse被调用后，执行结果会传递给第二个$parse，以此类推 1234567891011121314151617181920angular.module('myApp') .directive('oneToTen', function() &#123; return &#123; require: '?ngModel', link: function(scope, ele, attrs, ngModel) &#123; if (!ngModel) return; ngModel.$parsers.unshift( function(viewValue) &#123; var i = parseInt(viewValue); if (i &gt;= 0 &amp;&amp; i &lt; 10) &#123; ngModel.$setValidity('oneToTen', true); return viewValue; &#125; else &#123; ngModel.$setValidity('oneToTen', false); return undefined; &#125; &#125;); &#125; &#125;; &#125;); $formatters当绑定的ngModel值发生了变化，并经过$parsers数组中解析器的处理后，这个值会被传递给$formatters流水线。同$parsers数组可以修改表单的合法性状态类似， $formatters中的函数也可以修改并格式化这些值 123456789101112angular.module('myApp') .directive('oneToTen', function() &#123; return &#123; require: '?ngModel', link: function(scope, ele, attrs, ngModel) &#123; if (!ngModel) return; ngModel.$formatters.unshift(function(v) &#123; return $filter('number')(v); &#125;); &#125; &#125;; &#125;); 表单验证：ngModelController.$我是自定义 取出 form_name.input_name.$我是自定义 angular可以通过form_name.input_name.XX 拿到在directive里面给ngModelController自定义的布尔值 从而可以通过判断来进行show/hide的表单验证 用属性声明指令比较好 指令@ 绑定一次性显示的字符串= 双向绑定会获取作用域上面的值&amp; 绑定事件yourAttr: ‘@myAttr’ 在html用myAttr，在指令中还是用yourAttr ng-include会创建一个作用域，根据作用域原型继承原理，子作用域能访问父级的值，而反过来就不行了所以不能在父级作用域操作ng-include中的数据，导致无法正常进行$watch应该给1类似的指令还有 ```ng-controller ng-app 如要避免插值字符串{&#123; &#125;}为渲染完成闪烁问题，请使用ng-cloak指令 ng-attr-(suffix)如使用svg的时候报错，就是用前缀来避免 123456&lt;svg&gt; &lt;circle cx=\"&#123;&#123; cx &#125;&#125;\"&gt;&lt;/circle&gt; &lt;/svg&gt; // 报错&lt;svg&gt; &lt;circle ng-attr-cx=\"&#123;&#123; cx &#125;&#125;\"&gt;&lt;circle&gt;&lt;/svg&gt; // OK 指令的生命周期开始于$compile结束于link方法 指令API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.directive('', ['', function()&#123; // Runs during compile return &#123; name: '', `指令名称` priority: 1, `加载优先级` terminal: true, `是否让优先级以下的指令不运行` scope: &amp;#123; &amp;#125;, // &amp;#123; &amp;#125; = isolate, true = child, false/undefined = no change `作用域，如果是true则不让外部继承，外部读不到 如果是对象则是隔离作用域（作用域不传递） 具有隔离作用域的指令最主要的使用场景是创建可复用的组件，组件可以在未知上下文中使 用，并且可以避免污染所处的外部作用域或不经意地污染内部作用域` controller: function($scope, $element, $attrs, $transclude) &amp;#123; &amp;#125;, `指令的控制` require: 'ngModel', // Array = multiple requires, // ? = optional（指找不到控制器传递null）, // ^ = check parent elements // PS:可以在link方法的第四个参数指向该指令的controller restrict: 'A', // E = Element, // A = Attribute, // C = Class, // M = Comment // 声明方式 template: '', // 字符串 templateUrl: '', // 指令html的地址 replace: true, // 用html标签完全替代此指令 transclude: true, // 如果为true则无法正常监听数据变化，被用来， // 只有当你希望创建一个可以包含任意内容的指令时， // 才使用transclude: true。 // 配合ng-transclude插进去 compile: function(tElement, tAttrs, function transclude( function(scope, cloneLinkingFn)&#123; return function linking(scope, elm, attrs)&amp;#123; &amp;#125;&#125;)), link: function($scope, iElm, iAttrs, controller) &#123; &#125; &#125;; &#125;]) Angular生命周期 编译阶段： 遍历整个HTML，查找处理指令，遍历指令里面所有的模板，此时还没有数据绑定，ng-repeat和ng-include类似的就会在在此时进行操作，减少开销 compile：在数据放入指令之前安全操作DOM pre-link：将作用域与DOM连接起来之前操作dom，不安全的转换DOM post-link: 负责事件监听器，监听数据和实时的DOM操作，如果需要性能，用compile destroy ngModel 要访问ngModelController必须在指令里面require 不要有隔离作用域，隔离作用域会导致无法更新外部绑定的值 $viewValue 获取ngModel的值 $setViewValue 设置ngModel的值，需要手动触发$digest循环 $render自定义渲染，会在$parser流水线执行完后调用，慎用 $parsers：数组，处理加工ngModel数据，ngModel从DOM读出来的值会被当参数传入，到数据模型 $formatters 数组，在数据模型变的时候函数一一调用 $viewChangeListeners 无需$watch函数不需要返回值，视图中的值变化时一一调用 $error 没有通过验证的信息 $pristine 是否对控件没有交互过 $dirty 用户是否交互过 $valid 是否正确 $setValidity设置 $invalid 是否错误 constant会在所有配置config之前执行。config: 模块加载时会执行此函数 run 类main函数，在注入器创建之后被执行，是第一个被执行的方法，一般篇日志路由事件监听器每次路由改变时执行run方法 路由ng-view 最高权限指令同一元素只会运行ng-viewng-view运行顺序触发$routeChangeSuccess后试图会更新模板会通过路由与ng-view关联 创建一个新作用域 移除上一个视图，同时清除作用域 关联当前模板 如果路由中定义的controller则与当前作用域关联起来 触发$viewContentLoaded 调用onload指定的函数（如果有） router的resolve属性，$injector会将声明的key添加进依赖，并能注入 $location相当于window.location的封装，但只针对视图，不能针对全局浏览器窗口 依赖注入 对象通常过的其控制权的方式 在内部创建依赖； 通过全局变量进行引用； 在需要的地方通过参数进行传递 angular依赖注入使用$injector来管里依赖关系和实例化包括模块，指令，控制器的注入在运行时， 任何模块启动时$injector都会负责实例化，并将其需要的所有依赖传递进去 123456789101112131415161718angular.module('myApp', []) .factory('greeter', function() &#123; return &#123; greet: function(msg) &#123;alert(msg);&#125; &#125; &#125;) .controller('MyController', function($scope, greeter) &#123; $scope.sayHello = function() &#123; greeter.greet(\"Hello!\"); &#125;; &#125;); &lt;div ng-app=\"myApp\"&gt; &lt;div ng-controller=\"MyController\"&gt; &lt;button ng-click=\"sayHello()\"&gt;Hello&lt;/button&gt; &lt;/div&gt; &lt;/div angular加载过程123456// 使用注入器加载应用var injector = angular.injector(['ng', 'myApp']);// 通过注入器加载$controller服务： var $controller = injector.get('$controller');var scope = injector.get('$rootScope').$new();// 加载控制器并传入一个作用域，同AngularJS在运行时做的一样var MyController = $controller('MyController', &#123;$scope: scope&#125;) angular通过annotate函数将greeter从参数列表中提取出来如果没有加[]进行显式的声明，那么ng就会通过参数来获取依赖关系 12injector.annotate(function($q, myService)&#123; &#125;)// annotate会返回被注入目标中的服务的名称，从而进行匹配 injector.invoke(func($q)) 调用方法, fn.apply(self, args)将参数列表转化成实例后的函数在进行调用大概如此： 12345678910111213141516function Fucker() &#123; this.getFucker = function () &#123; console.log('motherfucker') &#125;&#125;function invoke(fn, self) &#123; // 一般是['dep1', 'dep2', func] // 会找寻依赖对应的参数函数并通过方法将其实例化 // 调用func fn.apply(self, [new Fucker()])&#125;invoke(function (fucker) &#123; fucker.getFucker() // motherfucker&#125;) 分析ng-include为什么会导致无法正常双向绑定 ng-include指令会生成一个作用域 (child) ng-include父节点的作用域（parent） parent.flag = “test” 根据原型继承原理 child.proto.flag = “test” 当parent.flag变成”dev” 则child.proto.flag = “dev” 如果child.flag = “product” 则 child.flag 与 parent.flag 失去联系 解决这种问题需要，将要传递的属性变为对象形式1234567891011121314151617181920212223242526272829303132333435363738394041424344 function Parent() &#123; this.face = \"哈哈\" &#125; Parent.prototype = &#123; constructor: Parent, $new: function () &#123; var child this.$$childScope = function () &#123; this.$id = 112212 &#125; this.$$childScope.prototype = this child = new this.$$childScope() return child &#125; &#125; var parentScope = new Parent() var childScope = parentScope.$new() console.log( [parentScope.face, parentScope.fixed.face], [childScope.face, childScope.fixed.face]) // [\"哈哈\", \"哈哈\"] [\"哈哈\", \"哈哈\"] parentScope.face = \"test\"parentScope.fixed.face = \"test\"console.log( [parentScope.face, parentScope.fixed.face], [childScope.face, childScope.fixed.face]) // [\"test\", \"test\"] [\"test\", \"test\"] childScope.face = \"我是谁\"childScope.fixed.face = \"我是谁\"console.log( [parentScope.face, parentScope.fixed.face], [childScope.face, childScope.fixed.face])// [\"test\", \"我是谁\"] [\"我是谁\", \"我是谁\"] $scope生命周期 创建 创建控制器或指令时，angular会用$injector创建一个作用域，并在新建的控制器指令中将作用域传递进去 $scope会通过$new创建通过原型与父级保持联系 链接 用$watch将数据监听 更新 当$watch监听到变化，触发回调 销毁 视图不需要会销毁自己","categories":[{"name":"课外学习","slug":"课外学习","permalink":"http://faceplus.top/categories/课外学习/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://faceplus.top/tags/angular/"},{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"}]},{"title":"vue-cli创建的任务和后台交互cookie及restAPI处理","slug":"vue-cli创建的任务和后台交互cookie及restAPI处理","date":"2017-04-14T03:34:51.000Z","updated":"2017-05-15T09:47:12.838Z","comments":true,"path":"2017/04/14/vue-cli创建的任务和后台交互cookie及restAPI处理/","link":"","permalink":"http://faceplus.top/2017/04/14/vue-cli创建的任务和后台交互cookie及restAPI处理/","excerpt":"在写vue和JAVA后台进行交互的时候，后端总是拿不到前端的cookiesession简述什么是session？ session是服务器储存信息的一种方式，一般称之为会话，以java为例request.getSession().setAttribute(key, value)在创建session实例时会生成一个唯一的ID，浏览器发送请求时，会将set-cookie返回给浏览器，浏览器自动存储在cookie中，在tomcat中，此Cookie叫做JSESSIONID session关键在于sessionID所以不用cookie存也是可以的，比如可以放在request param里面，只要需要时前台发过来就行","text":"在写vue和JAVA后台进行交互的时候，后端总是拿不到前端的cookiesession简述什么是session？ session是服务器储存信息的一种方式，一般称之为会话，以java为例request.getSession().setAttribute(key, value)在创建session实例时会生成一个唯一的ID，浏览器发送请求时，会将set-cookie返回给浏览器，浏览器自动存储在cookie中，在tomcat中，此Cookie叫做JSESSIONID session关键在于sessionID所以不用cookie存也是可以的，比如可以放在request param里面，只要需要时前台发过来就行 什么是cookie？ cookie是客户端（浏览器端）存储信息的一种方式，服务器可以设置浏览器set-cookie标头浏览器收到标头与数值，会以文件的形式存在与计算机中。浏览器发送请求时会自动将cookie发给服务端 cookie的属性 domain和path domain：domain表示的是cookie所在的域，默认为请求的地址，如网址为www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。 path: path表示cookie所在的目录，如baidu.com，cookie默认为根目录’/‘。baidu.com/wenku/，则path=/wenku/；如果在biadu.com/wenku/下面设置set-cookie，则在baidu.com下面浏览器会因为path不对应，导致在baidu.com下set-cookie失败 session的流程 request.getSession().setAttribute(“username”, “listen”) 在http response header里面设置set-cookie返回头 set-cookie: JSESSIONID=xxxxxxxx;path=/; 浏览器看到set-cookie信息，并且设置的domain和path与浏览器当前一致，否则等待匹配的path和domain，存储以后会自动清除掉set-cookie 浏览器向服务端发送请求，将存储的cookie以key=value的形式放到请求头里面 服务端获取session request.getSession().getAttribute(“username”) 从request请求头里面获取JSESSIONID，并找到与之对称的session实例，从此实例里面获取username 一个请求session对应一个实例，sessionId是区分实例的关键 回到问题 现在代理服务器的URI是 localhost:8080, api服务器URI是localhost:8084/articlepr/ api服务器设置session时，set-cookie是这样set-cookie:JSESSIONID=xxxx;path=/articlepr/; 现set-cookie的domain和浏览器URI（代理服务器）都为localhost，而path不一样，所以会导致set-cookie浏览器存储cookie失败，后台也就拿不到JSESSIONID了 解决问题既然是path不一样就修改path 方案 后台修改path，还得让后台搞，麻烦 方案 给代理服务器加上path后缀，使其和api服务器一样，但是这样对proxyTable有一点副作用 12345678910111213module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; var uri = `http://localhost:$&#123;port&#125;/articlepr/` console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;) // when env is testing, don&apos;t need open it if (process.env.NODE_ENV !== &apos;testing&apos;) &#123; opn(uri) &#125;&#125;) 方案 代理服务器重写path, 现使用的方式，不麻烦后台，不修改其他东西 1234567891011121314151617let options = proxyTable[ctx] if (typeof options === 'string') &#123; options = &#123; target: options, changeOrigin: true, onProxyRes(proxyRes, req, res) &#123; proxyRes.headers['set-cookie'] = [].slice.call(proxyRes.headers['set-cookie'] || '') .map(item =&gt; &#123; return item.replace(/Path=\\/.*?;/, 'Path=/;') &#125;) &#125; &#125; &#125; 这段代码就是将proxyRes.headers[‘set-cookie’]的path=/xx 转变成 path=/ 有时候在做代理请求的时候，需要拦截处理req的设置，查看http-proxy-middleware的文档，可以用filter做拦截，代码：12345app.use(proxyMiddleware((pathName, req) =&gt; &#123; pathName = req.originalUrl = req.url = `$&#123;rootAPI&#125;$&#123;req.url&#125;` return pathName.match(ctx) &#125;, options)) 最后vue proxy这块的总代码：1234567891011121314151617181920212223242526Object.keys(proxyTable).forEach(ctx =&gt; &#123; let options = proxyTable[ctx] if (typeof options === 'string') &#123; options = &#123; target: options, changeOrigin: true, onProxyRes(proxyRes, req, res) &#123; proxyRes.headers['set-cookie'] = [].slice.call(proxyRes.headers['set-cookie'] || '') .map(item =&gt; &#123; return item.replace(/Path=\\/.*?;/, 'Path=/;') &#125;) &#125; &#125; &#125; &#125; app.use(proxyMiddleware((pathName, req) =&gt; &#123; pathName = req.originalUrl = req.url = `$&#123;rootAPI&#125;$&#123;req.url&#125;` // 可以在此处进行处理request请求 return pathName.match(ctx) &#125;, options))&#125;)","categories":[{"name":"课外学习","slug":"课外学习","permalink":"http://faceplus.top/categories/课外学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://faceplus.top/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://faceplus.top/tags/vue/"},{"name":"cookie","slug":"cookie","permalink":"http://faceplus.top/tags/cookie/"},{"name":"node.js","slug":"node-js","permalink":"http://faceplus.top/tags/node-js/"}]}]}